# Example RISC-V ISA Constraint Configuration
# This file demonstrates practical constraint configuration for testing

# Global constraints - apply to all instructions
global_constraints:
  registers:
    # Use only registers 1-31 (exclude x0 for writes)
    rd_allowed: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
    rs1_allowed: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
    rs2_allowed: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
    exclude_zero_rd: true   # Don't write to x0
    exclude_zero_rs1: false # Can read from x0 (useful for comparisons)
    exclude_zero_rs2: false

  immediates:
    i_type:
      min: -100
      max: 100
    s_type:
      min: -100
      max: 100
    b_type:
      min: -50
      max: 50
      alignment: 2
    u_type:
      min: 0x10000
      max: 0x50000
    j_type:
      min: -200
      max: 200
      alignment: 2

# Instruction groups for different test scenarios
instruction_groups:
  # Test scenario 1: Arithmetic operations on temporary registers
  arithmetic_temps:
    description: "Arithmetic on temporary registers t0-t6"
    instructions: ["add", "sub", "xor", "or", "and", "addi", "xori", "ori", "andi"]
    constraints:
      registers:
        rd_allowed: [5, 6, 7, 28, 29, 30, 31]  # t0-t2, t3-t6
        rs1_allowed: [5, 6, 7, 28, 29, 30, 31]
        rs2_allowed: [5, 6, 7, 28, 29, 30, 31]
      weight: 2.0  # Emphasize arithmetic operations

  # Test scenario 2: Memory operations using stack pointer
  memory_stack:
    description: "Load/store operations relative to stack pointer (x2)"
    instructions: ["lw", "sw", "lb", "sb", "lh", "sh", "lbu", "lhu"]
    constraints:
      registers:
        # For loads: destination can be any temp register
        rd_allowed: [5, 6, 7, 28, 29, 30, 31]
        # Base address register should be stack pointer (x2) or saved registers
        rs1_allowed: [2, 8, 9, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]  # sp, s0-s11
        # For stores: source can be temp registers
        rs2_allowed: [5, 6, 7, 28, 29, 30, 31]
      immediates:
        i_type:  # loads use I-type
          min: -64   # Small stack offsets
          max: 63
        s_type:  # stores use S-type
          min: -64
          max: 63
      weight: 1.5

  # Test scenario 3: Function call/return patterns
  function_ops:
    description: "Function call and return instructions"
    instructions: ["jal", "jalr"]
    constraints:
      registers:
        # jal can write to ra (x1) or temporary
        rd_allowed: [1, 5, 6, 7]
        # jalr can use ra or saved registers as base
        rs1_allowed: [1, 8, 9]
      immediates:
        j_type:  # jal
          min: -1000
          max: 1000
          alignment: 2
        i_type:  # jalr
          min: 0    # Usually 0 for return
          max: 0
      weight: 0.8

  # Test scenario 4: Control flow with small branches
  control_flow:
    description: "Branch instructions for tight loops"
    instructions: ["beq", "bne", "blt", "bge"]
    constraints:
      registers:
        # Compare temporary registers or with zero
        rs1_allowed: [5, 6, 7, 28, 29, 30, 31, 0]  # temps or x0
        rs2_allowed: [5, 6, 7, 28, 29, 30, 31, 0]
      immediates:
        b_type:
          min: -20   # Short forward/backward branches
          max: 20
          alignment: 2
      weight: 1.0

# Instruction-specific overrides for special cases
instruction_overrides:
  addi:
    description: "addi with small immediates for address calculation"
    constraints:
      immediates:
        i_type:
          min: -4
          max: 4
      weight: 3.0  # Very common

  lui:
    description: "lui for specific address ranges"
    constraints:
      immediates:
        u_type:
          allowed_values: [0x10000, 0x20000, 0x30000, 0x40000]
      weight: 0.5

  auipc:
    description: "auipc for PC-relative addressing"
    constraints:
      immediates:
        u_type:
          min: 0x0
          max: 0x1000
      weight: 0.3

  ecall:
    description: "System call - rarely used in tests"
    constraints:
      weight: 0.01  # Very low probability

  ebreak:
    description: "Breakpoint - rarely used"
    constraints:
      weight: 0.01

# Usage notes:
# 1. This configuration emphasizes testing common patterns:
#    - Arithmetic on temporary registers
#    - Stack-relative memory operations
#    - Function calls and returns
#    - Small branch offsets
#
# 2. To use with riscv_rtg, the constraint system would need to be
#    integrated into the generator to respect these constraints.
#
# 3. Weights are relative probabilities within their selection context.