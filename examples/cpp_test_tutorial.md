# Using Generated RISC-V Instructions in C++ Tests

This tutorial demonstrates how to use the RISC-V random instruction generator (`riscv_rtg`) to create test programs for C++ shader system tests.

## Overview

The `riscv_rtg` tool can generate random RISC-V instructions that can be:
1. Exported as C++ arrays for inclusion in test programs
2. Used to test instruction decoders and execution units
3. Validated against reference implementations
4. Used for fuzz testing and coverage analysis

## Prerequisites

- Python 3.6+ with `riscv_rtg` installed or available in PYTHONPATH
- C++ shader system with `riscv_isa.h` and generated headers
- Basic understanding of RISC-V instruction encoding

## Step 1: Generate Test Instructions

### Using the Python Generator

Create a Python script to generate instructions and export them as C++ code:

```python
#!/usr/bin/env python3
"""generate_test_program.py - Generate C++ test program."""

import sys
sys.path.insert(0, 'src')  # Adjust path as needed

from riscv_rtg.isa.riscv_isa import RISCVISA
import random

def generate_cpp_array(count=100, seed=42):
    """Generate C++ array with random instructions."""
    random.seed(seed)
    isa = RISCVISA()
    instructions = isa.generate_random(count)

    print("// Auto-generated RISC-V test program")
    print(f"// Generated by riscv_rtg with seed={seed}")
    print(f"// Instruction count: {count}")
    print("// Includes RV32I + RV32M instructions")
    print()
    print("#include <cstdint>")
    print("#include <vector>")
    print()
    print("namespace test_data {")
    print()
    print(f"constexpr size_t PROGRAM_SIZE = {count};")
    print()
    print("const std::vector<uint32_t> test_program = {")

    for i, (encoded, asm_str) in enumerate(instructions):
        comment = f"  // {asm_str}" if asm_str else ""
        print(f"    0x{encoded:08x},{comment}")

    print("};")
    print()
    print("} // namespace test_data")

    return instructions

if __name__ == "__main__":
    # Generate 50 instructions with reproducible seed
    generate_cpp_array(count=50, seed=12345)
```

### Using the Example Script

The project includes a ready-to-use example:

```bash
# Run the shader system integration example
python3 examples/shader_system_integration.py

# Or generate directly from command line
python3 -c "
import sys
sys.path.insert(0, 'src')
from riscv_rtg.isa.riscv_isa import RISCVISA
isa = RISCVISA()
for encoded, asm in isa.generate_random(10):
    print(f'0x{encoded:08x}, // {asm}')
"
```

## Step 2: Integrate with C++ Tests

### Basic Test Structure

Create a C++ test file that includes the generated instructions:

```cpp
// test_riscv_decoder.cpp
#include <cstdint>
#include <vector>
#include <iostream>
#include <cassert>

#include "riscv_isa.h"
#include "riscv_isa_generated.h"

// Include the generated test program
#include "test_program.h"  // Generated by Python script

void test_decoder() {
    shader_system::RiscvISA riscv_isa;

    std::cout << "Testing RISC-V decoder with "
              << test_data::PROGRAM_SIZE
              << " instructions..." << std::endl;

    uint32_t pc = 0x1000;  // Start address

    for (size_t i = 0; i < test_data::PROGRAM_SIZE; ++i) {
        uint32_t instr_word = test_data::test_program[i];

        // Decode the instruction
        auto decoded = riscv_isa.decodeInstruction(instr_word, pc);

        // Verify basic properties
        assert(decoded.size == 4);  // RV32I instructions are 4 bytes

        // Look up metadata using generated lookup tables
        auto* meta = shader_system::getInstructionMetadata(
            decoded.opcode, decoded.funct3, decoded.funct7);

        if (meta) {
            std::cout << "[" << i << "] "
                      << meta->mnemonic
                      << " (0x" << std::hex << instr_word << std::dec << ")"
                      << std::endl;

            // Verify mnemonic matches
            assert(decoded.mnemonic == meta->mnemonic);

            // Check instruction type
            assert(decoded.type == meta->type);
        } else {
            std::cerr << "Warning: Unknown instruction: 0x"
                      << std::hex << instr_word << std::dec << std::endl;
        }

        pc += 4;  // Move to next instruction
    }

    std::cout << "Decoder test passed!" << std::endl;
}

int main() {
    test_decoder();
    return 0;
}
```

### Advanced Test: Instruction Execution

Test instruction execution with a simple simulator:

```cpp
// test_riscv_execution.cpp
#include "riscv_isa.h"
#include "test_program.h"

class SimpleSimulator {
    uint32_t registers[32] = {0};
    uint32_t pc = 0x1000;

public:
    void execute_test_program() {
        shader_system::RiscvISA riscv_isa;

        // Initialize registers with test values
        for (int i = 1; i < 32; ++i) {
            registers[i] = i * 0x1000;  // Simple pattern
        }

        // Create execution context
        shader_system::RiscvExecutionContext context;
        context.registers = registers;
        context.pc = pc;

        for (uint32_t instr_word : test_data::test_program) {
            // Decode
            auto instr = riscv_isa.decodeInstruction(instr_word, context.pc);

            // Execute
            auto result = riscv_isa.executeInstruction(instr, context);

            // Check for errors
            if (result == shader_system::RiscvExecutionResult::ILLEGAL_INSTRUCTION) {
                std::cerr << "Illegal instruction: 0x"
                          << std::hex << instr_word << std::dec << std::endl;
                break;
            }

            // Update PC based on execution result
            if (result == shader_system::RiscvExecutionResult::BRANCH_TAKEN ||
                result == shader_system::RiscvExecutionResult::JUMP) {
                context.pc = context.next_pc;
            } else {
                context.pc += 4;
            }
        }

        std::cout << "Program executed. Final PC: 0x"
                  << std::hex << context.pc << std::dec << std::endl;
    }
};
```

## Step 3: Build Integration

### CMake Integration

Add generation to your CMake build process:

```cmake
# CMakeLists.txt
find_package(Python3 REQUIRED)

# Custom command to generate test program
add_custom_command(
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/test_program.h
    COMMAND ${Python3_EXECUTABLE}
        ${CMAKE_SOURCE_DIR}/scripts/generate_test_program.py
        --count 100
        --seed ${TEST_SEED}
        --output ${CMAKE_CURRENT_BINARY_DIR}/test_program.h
    DEPENDS scripts/generate_test_program.py
    COMMENT "Generating RISC-V test program"
)

# Add test executable
add_executable(test_riscv_decoder test_riscv_decoder.cpp)
target_include_directories(test_riscv_decoder PRIVATE
    ${CMAKE_CURRENT_BINARY_DIR}
    ${SHADER_SYSTEM_INCLUDE_DIR}
)
target_link_libraries(test_riscv_decoder shader_system)

# Add dependency on generated header
add_dependencies(test_riscv_decoder test_program.h)
```

### Makefile Integration

```makefile
# Makefile
TEST_SEED ?= 42
TEST_COUNT ?= 100

.PHONY: generate-test
generate-test:
	python3 scripts/generate_test_program.py \
		--count $(TEST_COUNT) \
		--seed $(TEST_SEED) \
		--output test_program.h

test_decoder: test_riscv_decoder.cpp test_program.h
	$(CXX) -std=c++17 -I. -I../shader_system/include \
		-o test_decoder test_riscv_decoder.cpp \
		-L../shader_system/build -lshader_system

test: test_decoder
	./test_decoder
```

## Step 4: Validation and Verification

### Python-C++ Cross Validation

Create a Python script to verify C++ decoding matches Python generation:

```python
#!/usr/bin/env python3
"""verify_decoding.py - Cross-language validation."""

import sys
sys.path.insert(0, 'src')

from riscv_rtg.isa.riscv_isa import RISCVISA
import random

def verify_with_seed(seed, count):
    """Generate with Python, verify with C++ output."""
    random.seed(seed)
    isa = RISCVISA()
    py_instructions = isa.generate_random(count)

    print(f"Generated {count} instructions with seed {seed}")
    print("First 5 instructions:")

    for i, (encoded, asm) in enumerate(py_instructions[:5]):
        print(f"  {i}: 0x{encoded:08x} {asm}")

    # Write to file for C++ comparison
    with open('python_generated.txt', 'w') as f:
        for encoded, asm in py_instructions:
            f.write(f"0x{encoded:08x} // {asm}\n")

    print("\nInstructions saved to python_generated.txt")
    print("Compare with C++ decoder output.")

    return py_instructions

if __name__ == "__main__":
    verify_with_seed(12345, 50)
```

### Statistical Validation

Check instruction distribution matches expected probabilities:

```python
from collections import Counter

def validate_distribution(count=10000, seed=42):
    random.seed(seed)
    isa = RISCVISA()
    instructions = isa.generate_random(count)

    # Count instruction types
    type_counter = Counter()
    for instr in isa.instructions:
        type_counter[instr.format.value] += 1

    # Calculate expected frequencies
    print("Instruction format distribution:")
    for fmt, instr_count in sorted(type_counter.items()):
        expected_pct = instr_count / len(isa.instructions) * 100
        print(f"  {fmt}: {instr_count} instructions ({expected_pct:.1f}% each)")

    # Count actual generated instructions by type
    actual_counter = Counter()
    for encoded, asm in instructions:
        if asm:
            name = asm.split()[0]
            actual_counter[name] += 1

    print(f"\nTop 10 most frequent instructions (n={count}):")
    for name, freq in actual_counter.most_common(10):
        pct = freq / count * 100
        print(f"  {name:6}: {freq:4} ({pct:5.1f}%)")
```

## Step 5: Advanced Testing Scenarios

### Testing RV32M Multiply/Divide Extension

The generator includes RV32M instructions. Test them specifically:

```cpp
void test_rv32m_instructions() {
    // Generate instructions with RV32M bias
    std::vector<uint32_t> rv32m_test = {
        0x021300b3,  // mul x1, x6, x1
        0x02235133,  // mulh x2, x6, x2
        0x023391b3,  // mulhsu x3, x7, x3
        0x0243d233,  // mulhu x4, x7, x4
        0x025454b3,  // div x9, x8, x5
        0x0264d533,  // divu x10, x9, x6
        0x0275e5b3,  // rem x11, x11, x7
        0x0286f633,  // remu x12, x13, x8
    };

    shader_system::RiscvISA riscv_isa;

    for (uint32_t instr : rv32m_test) {
        auto decoded = riscv_isa.decodeInstruction(instr, 0x1000);
        auto* meta = shader_system::getInstructionMetadata(
            decoded.opcode, decoded.funct3, decoded.funct7);

        assert(meta != nullptr);
        std::cout << "RV32M: " << meta->mnemonic
                  << " (funct7=" << static_cast<int>(decoded.funct7)
                  << ")" << std::endl;
    }
}
```

### Pattern-Based Testing

Use the pattern generator to create realistic instruction sequences:

```bash
# Generate load-store patterns for memory testing
python3 -m generator --pattern load-store -n 50 -f hexasm

# Generate RAW hazards for pipeline testing
python3 -m generator --pattern raw -n 50 -f hexasm

# Generate mixed patterns with density control
python3 -m generator --pattern mixed --pattern-density 0.3 -n 100 -f hexasm
```

## Best Practices

1. **Reproducibility**: Always use seeds for reproducible test generation
2. **Coverage**: Generate large instruction sets to ensure coverage of all instruction types
3. **Validation**: Cross-validate between Python generator and C++ decoder
4. **Performance**: Generate test programs offline, not during build time for large tests
5. **Documentation**: Document the seed and generation parameters used for each test

## Troubleshooting

### Common Issues

1. **Missing generated headers**: Ensure `generate_cpp.py` has been run to create `riscv_isa_generated.h`
2. **Instruction count mismatch**: Verify Python and C++ are using the same YAML definitions
3. **RV32M instructions not appearing**: Check that `MULDIV` funct7 value is defined in both Python and C++ enums
4. **Build dependency issues**: Ensure generated headers are built before test compilation

### Debug Tips

- Use `--list-instructions` to verify RV32M instructions are loaded
- Run `python3 generated/test_shader_integration.py` to verify integration
- Check enum values match between `riscv_isa.h` and `enums.py`
- Use small test counts (5-10) for initial verification

## Next Steps

1. Explore the constraint system for more controlled instruction generation
2. Add custom instruction definitions for GPU extensions
3. Integrate with coverage tools to measure test effectiveness
4. Create fuzz testing harness using random instruction generation

## See Also

- [Shader System Integration Example](../examples/shader_system_integration.py)
- [Basic Usage Examples](../examples/basic_usage.py)
- [YAML Definition Format](./yaml_definition_format.md)
- [Main README](../README.md)