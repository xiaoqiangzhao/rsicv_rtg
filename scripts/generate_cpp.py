#!/usr/bin/env python3
"""
Generate C++ headers and source files from unified RISC-V ISA YAML definitions.

This script reads the unified YAML instruction definitions and generates:
1. riscv_isa_generated.h - Instruction metadata and lookup tables
2. riscv_isa_generated.cpp - Static data definitions
3. riscv_isa_test.py - Python test to verify consistency with C++ header

The generated files can be included in the shader system to ensure consistency
between the Python random instruction generator and the C++ decoder.
"""

import os
import sys
import yaml
from typing import Dict, List, Any, Optional
import pathlib

# Add parent directory to path to import riscv_rtg modules
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))
from riscv_rtg.isa.enums import RiscvOpcode, RiscvFunct3, RiscvFunct7, RiscvInstructionType


def load_yaml_definitions(yaml_path: str) -> Dict[str, Any]:
    """Load YAML instruction definitions."""
    with open(yaml_path, 'r') as f:
        return yaml.safe_load(f)


def generate_header(data: Dict[str, Any], output_path: str) -> None:
    """Generate C++ header file with instruction metadata."""

    enums = data['enums']
    instructions = data['instructions']

    # Map format strings to C++ RiscvInstructionType enum values
    format_to_cpp_type = {
        'R_TYPE': 'RiscvInstructionType::R_TYPE',
        'I_TYPE': 'RiscvInstructionType::I_TYPE',
        'S_TYPE': 'RiscvInstructionType::S_TYPE',
        'B_TYPE': 'RiscvInstructionType::B_TYPE',
        'U_TYPE': 'RiscvInstructionType::U_TYPE',
        'J_TYPE': 'RiscvInstructionType::J_TYPE',
    }

    # Build mapping from enum names to values for lookup
    opcode_map = {name: value for name, value in enums['opcode'].items()}
    funct3_map = {name: value for name, value in enums['funct3'].items()}
    funct7_map = {name: value for name, value in enums['funct7'].items()}

    header_content = f"""// RISC-V ISA generated header
// Auto-generated from YAML definitions - DO NOT EDIT DIRECTLY
// Generated by {os.path.basename(__file__)}

#pragma once

#include <cstdint>
#include <string_view>
#include "riscv_isa.h"

namespace shader_system {{

/**
 * @brief RISC-V instruction metadata.
 */
struct RiscvInstructionMetadata {{
    std::string_view mnemonic;          // Instruction mnemonic (e.g., "add")
    RiscvOpcode opcode;                 // Opcode value
    RiscvFunct3 funct3;                 // Function 3 value (if applicable)
    RiscvFunct7 funct7;                 // Function 7 value (if applicable)
    RiscvInstructionType type;          // Instruction type
    bool has_immediate;                 // Whether instruction has immediate
    uint8_t imm_bits;                   // Immediate bit width (0 if none)
    bool imm_signed;                    // Whether immediate is signed
    uint8_t imm_align;                  // Immediate alignment requirement (1=no alignment)
}};

/**
 * @brief Get instruction metadata by opcode, funct3, and funct7.
 *
 * @param opcode Instruction opcode.
 * @param funct3 Function 3 field (0 if not applicable).
 * @param funct7 Function 7 field (0 if not applicable).
 * @return const RiscvInstructionMetadata* Pointer to metadata, or nullptr if not found.
 */
const RiscvInstructionMetadata* getInstructionMetadata(
    RiscvOpcode opcode, RiscvFunct3 funct3, RiscvFunct7 funct7);

/**
 * @brief Get instruction metadata by mnemonic.
 *
 * @param mnemonic Instruction mnemonic (e.g., "add").
 * @return const RiscvInstructionMetadata* Pointer to metadata, or nullptr if not found.
 */
const RiscvInstructionMetadata* getInstructionMetadata(std::string_view mnemonic);

/**
 * @brief Total number of defined instructions.
 */
constexpr size_t RISCV_INSTRUCTION_COUNT = {len(instructions)};

/**
 * @brief Array of all instruction metadata.
 */
extern const RiscvInstructionMetadata RISCV_INSTRUCTION_TABLE[RISCV_INSTRUCTION_COUNT];

}} // namespace shader_system
"""

    with open(output_path, 'w') as f:
        f.write(header_content)

    print(f"Generated header: {output_path}")


def generate_source(data: Dict[str, Any], output_path: str) -> None:
    """Generate C++ source file with instruction metadata table."""

    enums = data['enums']
    instructions = data['instructions']

    # Build mapping from enum names to values
    opcode_map = {name: value for name, value in enums['opcode'].items()}
    funct3_map = {name: value for name, value in enums['funct3'].items()}
    funct7_map = {name: value for name, value in enums['funct7'].items()}

    # Map format strings to C++ RiscvInstructionType enum values
    format_to_cpp_type = {
        'R_TYPE': 'RiscvInstructionType::R_TYPE',
        'I_TYPE': 'RiscvInstructionType::I_TYPE',
        'S_TYPE': 'RiscvInstructionType::S_TYPE',
        'B_TYPE': 'RiscvInstructionType::B_TYPE',
        'U_TYPE': 'RiscvInstructionType::U_TYPE',
        'J_TYPE': 'RiscvInstructionType::J_TYPE',
    }

    # Generate metadata table entries
    table_entries = []
    for instr_def in instructions:
        mnemonic = instr_def['mnemonic']
        fmt_str = instr_def['format']

        # Resolve enum values
        opcode = opcode_map[instr_def['opcode']]
        funct3 = instr_def.get('funct3')
        funct7 = instr_def.get('funct7')

        # Immediate specification
        imm_spec = instr_def.get('immediate')
        has_immediate = imm_spec is not None
        imm_bits = imm_spec['bits'] if has_immediate else 0
        imm_signed = imm_spec.get('signed', False) if has_immediate else False
        imm_align = imm_spec.get('align', 1) if has_immediate else 1

        # Format C++ values
        opcode_val = f"static_cast<RiscvOpcode>({opcode})"
        funct3_val = f"static_cast<RiscvFunct3>({funct3_map[funct3]})" if funct3 else "static_cast<RiscvFunct3>(0)"
        funct7_val = f"static_cast<RiscvFunct7>({funct7_map[funct7]})" if funct7 else "static_cast<RiscvFunct7>(0)"
        type_val = format_to_cpp_type[fmt_str]

        # Create table entry
        entry = f"""    {{"{mnemonic}", {opcode_val}, {funct3_val}, {funct7_val}, {type_val}, {str(has_immediate).lower()}, {imm_bits}, {str(imm_signed).lower()}, {imm_align}}}"""
        table_entries.append(entry)

    table_str = ',\n'.join(table_entries)

    # Generate lookup function implementations
    lookup_functions = """
// Helper function to compare enum values with metadata
static bool matches_metadata(const RiscvInstructionMetadata& meta,
                             RiscvOpcode opcode, RiscvFunct3 funct3, RiscvFunct7 funct7) {
    return meta.opcode == opcode &&
           (meta.funct3 == funct3 || meta.funct3 == static_cast<RiscvFunct3>(0)) &&
           (meta.funct7 == funct7 || meta.funct7 == static_cast<RiscvFunct7>(0));
}

const RiscvInstructionMetadata* getInstructionMetadata(
    RiscvOpcode opcode, RiscvFunct3 funct3, RiscvFunct7 funct7) {

    for (size_t i = 0; i < RISCV_INSTRUCTION_COUNT; ++i) {
        if (matches_metadata(RISCV_INSTRUCTION_TABLE[i], opcode, funct3, funct7)) {
            return &RISCV_INSTRUCTION_TABLE[i];
        }
    }
    return nullptr;
}

const RiscvInstructionMetadata* getInstructionMetadata(std::string_view mnemonic) {
    for (size_t i = 0; i < RISCV_INSTRUCTION_COUNT; ++i) {
        if (RISCV_INSTRUCTION_TABLE[i].mnemonic == mnemonic) {
            return &RISCV_INSTRUCTION_TABLE[i];
        }
    }
    return nullptr;
}
"""

    source_content = f"""// RISC-V ISA generated source
// Auto-generated from YAML definitions - DO NOT EDIT DIRECTLY
// Generated by {os.path.basename(__file__)}

#include "riscv_isa_generated.h"

namespace shader_system {{

const RiscvInstructionMetadata RISCV_INSTRUCTION_TABLE[RISCV_INSTRUCTION_COUNT] = {{
{table_str}
}};

{lookup_functions}

}} // namespace shader_system
"""

    with open(output_path, 'w') as f:
        f.write(source_content)

    print(f"Generated source: {output_path}")


def generate_test_python(data: Dict[str, Any], output_path: str, cpp_header_path: str) -> None:
    """Generate Python test to verify consistency with C++ header."""

    # This is a simple test that can be extended to validate enum values
    test_content = f"""#!/usr/bin/env python3
"""
    # For now, just create a placeholder
    test_content += f"""
# Python test for C++ code generation
# This test verifies that the generated C++ code matches the YAML definitions

import os
import sys
import yaml

def test_consistency():
    \"\"\"Basic consistency test.\"\"\"
    yaml_path = os.path.join(os.path.dirname(__file__), '..', 'src', 'riscv_rtg', 'isa', 'definitions', 'rv32i.yaml')
    with open(yaml_path, 'r') as f:
        data = yaml.safe_load(f)

    # Check that we have the expected number of instructions
    expected_count = len(data['instructions'])
    print(f"YAML defines {{expected_count}} instructions")

    # TODO: Add more comprehensive tests
    # - Verify enum values match C++ header
    # - Verify instruction formats are valid
    # - Verify immediate specifications are consistent

    return True

if __name__ == '__main__':
    success = test_consistency()
    sys.exit(0 if success else 1)
"""

    with open(output_path, 'w') as f:
        f.write(test_content)

    print(f"Generated Python test: {output_path}")


def main():
    """Main generation function."""

    # Paths
    project_root = os.path.dirname(os.path.dirname(__file__))
    yaml_path = os.path.join(project_root, 'src', 'riscv_rtg', 'isa', 'definitions', 'rv32i.yaml')

    # Output paths
    output_dir = os.path.join(project_root, 'generated')
    header_path = os.path.join(output_dir, 'riscv_isa_generated.h')
    source_path = os.path.join(output_dir, 'riscv_isa_generated.cpp')
    test_path = os.path.join(output_dir, 'test_consistency.py')

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    # Load YAML definitions
    print(f"Loading YAML definitions from: {yaml_path}")
    data = load_yaml_definitions(yaml_path)

    # Generate files
    generate_header(data, header_path)
    generate_source(data, source_path)
    generate_test_python(data, test_path, header_path)

    print(f"\nGeneration complete. Files saved to: {output_dir}")
    print("Next steps:")
    print("1. Include 'riscv_isa_generated.h' in the shader system's riscv_isa.h")
    print("2. Rebuild shader system with generated files")
    print("3. Run test_consistency.py to verify consistency")


if __name__ == '__main__':
    main()
